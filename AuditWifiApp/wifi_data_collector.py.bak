"""
Collecteur de données WiFi pour l'audit de couverture
"""
import os
import json
import logging
import logging.handlers
import threading
import time
from datetime import datetime
from typing import List, Optional, Dict

from models.measurement_record import WifiMeasurement, PingMeasurement, NetworkStatus
from models.wifi_record import WifiRecord
from wifi.powershell_collector import PowerShellWiFiCollector

# Constantes de configuration
RETRY_CONFIG = {
    'MAX_RETRIES': 3,
    'RETRY_DELAY': 2,  # secondes
    'SCAN_TIMEOUT': 10,  # secondes
    'PING_TIMEOUT': 10,  # secondes
}

# Seuils de qualité WiFi
WIFI_THRESHOLDS = {
    'SIGNAL_WEAK': -70,    # dBm, seuil pour signal faible
    'SIGNAL_CRITICAL': -80,  # dBm, seuil critique
    'PACKET_LOSS_WARNING': 10,  # %, seuil d'avertissement pour perte de paquets
    'PACKET_LOSS_CRITICAL': 20,  # %, seuil critique pour perte de paquets
    'LATENCY_WARNING': 100,  # ms, seuil d'avertissement pour la latence
    'LATENCY_CRITICAL': 200,  # ms, seuil critique pour la latence
}

class WifiDataCollector:
    def __init__(self, base_path: str = "logs_moxa"):
        """Initialise le collecteur avec le chemin de base pour les logs"""
        self.base_path = base_path
        self.current_cycle: int = 0
        self.current_zone: str = "Non spécifiée"
        self.current_location_tag: str = ""
        self.is_collecting = False
        self.measurement_lock = threading.Lock()
        self._setup_logging()
        self.ps_collector = PowerShellWiFiCollector()
        self.records = []

    def _setup_logging(self):
        """Configure le système de logging"""
        self.logger = logging.getLogger('wifi_collector')
        self.logger.setLevel(logging.DEBUG)

        # Configurer le formatage
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

        # Handler pour la console avec niveau INFO
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        console_handler.setFormatter(formatter)
        self.logger.addHandler(console_handler)

        # Handler pour le fichier avec rotation et niveau DEBUG
        log_file = os.path.join(self.base_path, 'wifi_collector.log')
        os.makedirs(os.path.dirname(log_file), exist_ok=True)
        file_handler = logging.handlers.RotatingFileHandler(
            log_file,
            maxBytes=5*1024*1024,  # 5 MB
            backupCount=5,
            encoding='utf-8'
        )
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)

    def _create_wifi_measurement_from_ps(self, wifi_data: Dict) -> Optional[WifiMeasurement]:
        """Crée un objet WifiMeasurement à partir des données PowerShell"""
        try:
            measurement = WifiMeasurement(
                bssid=wifi_data.get('BSSID', ''),
                ssid=wifi_data.get('SSID', ''),
                signal_strength=wifi_data.get('Signal', 0),
                channel=int(wifi_data.get('Channel', 0)),
                frequency=wifi_data.get('Frequency', ''),
                band=wifi_data.get('Band', ''),
                encryption=wifi_data.get('Authentication', ''),
                network_type=wifi_data.get('NetworkType', '')
            )
            return measurement
        except Exception as e:
            self.logger.error(f"Erreur lors de la création de la mesure WiFi: {str(e)}")
            return None

    def start_collection(self, zone: str = "", location_tag: str = "", interval: float = 1.0) -> bool:
        """Démarre la collecte de données WiFi"""
        if self.is_collecting:
            return False

        self.current_zone = zone
        self.current_location_tag = location_tag
        self.is_collecting = True

        # Démarre la collecte PowerShell avec callback
        self.ps_collector.start_collection(
            callback=self._handle_wifi_data,
            interval=interval
        )

        self.logger.info(f"Collection démarrée - Zone: {zone}, Tag: {location_tag}")
        return True

    def stop_collection(self) -> bool:
        """Arrête la collecte de données WiFi"""
        if not self.is_collecting:
            return False

        self.is_collecting = False
        
        # Récupère et sauvegarde les données de la session
        session_data = self.ps_collector.stop_collection()
        if session_data:
            self.ps_collector.save_session_data(self.base_path)
            
        self.logger.info("Collection arrêtée")
        return True

    def _handle_wifi_data(self, wifi_data: Dict):
        """Traite les données WiFi reçues du collecteur PowerShell"""
        with self.measurement_lock:
            try:
                timestamp = datetime.fromisoformat(wifi_data['timestamp'])
                wifi_measurement = self._create_wifi_measurement_from_ps(wifi_data)
                
                if not wifi_measurement:
                    return
                    
                # Créer le ping measurement si disponible
                ping_measurement = None
                if int(wifi_data.get('PingLatency', -1)) >= 0:
                    ping_measurement = PingMeasurement(
                        latency=int(wifi_data['PingLatency']),
                        packet_loss=int(wifi_data.get('PacketLoss', 0))
                    )

                # Créer le record
                record = WifiRecord(
                    timestamp=timestamp,
                    zone=self.current_zone,
                    location_tag=self.current_location_tag,
                    cycle=self.current_cycle,
                    wifi_measurement=wifi_measurement,
                    ping_measurement=ping_measurement
                )

                # Ajouter à la liste des records
                self.records.append(record)
                self.logger.debug(f"Nouvelle mesure enregistrée: {record}")
                
            except Exception as e:
                self.logger.error(f"Erreur lors du traitement des données WiFi: {str(e)}")

    def get_current_status(self) -> NetworkStatus:
        """Retourne le statut actuel basé sur la dernière mesure"""
        if not self.records:
            return NetworkStatus.UNKNOWN
            
        last_record = self.records[-1]
        wifi_meas = last_record.wifi_measurement
        ping_meas = last_record.ping_measurement
        
        if not wifi_meas:
            return NetworkStatus.NO_SIGNAL
            
        # Vérifier le signal WiFi
        if wifi_meas.signal_strength <= WIFI_THRESHOLDS['SIGNAL_CRITICAL']:
            return NetworkStatus.CRITICAL
        elif wifi_meas.signal_strength <= WIFI_THRESHOLDS['SIGNAL_WEAK']:
            return NetworkStatus.WARNING
            
        # Vérifier le ping si disponible
        if ping_meas:
            if ping_meas.packet_loss >= WIFI_THRESHOLDS['PACKET_LOSS_CRITICAL'] or \
               ping_meas.latency >= WIFI_THRESHOLDS['LATENCY_CRITICAL']:
                return NetworkStatus.CRITICAL
            elif ping_meas.packet_loss >= WIFI_THRESHOLDS['PACKET_LOSS_WARNING'] or \
                 ping_meas.latency >= WIFI_THRESHOLDS['LATENCY_WARNING']:
                return NetworkStatus.WARNING
                
        return NetworkStatus.GOOD

    def get_latest_record(self) -> Optional[WifiRecord]:
        """Retourne le dernier enregistrement"""
        if not self.records:
            return None
        return self.records[-1]

    def collect_sample(self) -> Optional[WifiRecord]:
        """Collecte un échantillon complet de données WiFi avec le script PowerShell"""
        start_time = time.time()
        self.logger.info("Démarrage de la collecte de données...")

        try:
            # Obtenir les données via PowerShell
            wifi_data = self.ps_collector.get_wifi_data()
            if not wifi_data:
                self.logger.error("Impossible de collecter les données WiFi")
                return None

            # Créer la mesure WiFi
            wifi_measurement = self._create_wifi_measurement_from_ps(wifi_data)
            if not wifi_measurement:
                return None

            # Créer le ping measurement si disponible
            ping_measurement = None
            if int(wifi_data.get('PingLatency', -1)) >= 0:
                ping_measurement = PingMeasurement(
                    target=wifi_data.get('Gateway', 'unknown'),
                    min_ms=int(wifi_data['PingLatency']),
                    max_ms=int(wifi_data['PingLatency']),
                    avg_ms=int(wifi_data['PingLatency']),
                    lost_percent=0 if wifi_data.get('PingLatency', -1) >= 0 else 100,
                    jitter_ms=0
                )

            # Créer l'enregistrement
            record = WifiRecord(
                timestamp=datetime.now(),
                cycle_id=self.current_cycle,
                wifi_measurement=wifi_measurement,
                ping_measurement=ping_measurement,
                network_status=NetworkStatus(
                    link_speed_mbps=int(wifi_data.get('TransmitRate', '0').replace(' Mbps', '')),
                    rx_rate_mbps=int(wifi_data.get('ReceiveRate', '0').replace(' Mbps', '')),
                    tx_rate_mbps=int(wifi_data.get('TransmitRate', '0').replace(' Mbps', ''))
                ),
                location_tag=self.current_location_tag,
                zone=self.current_zone,
                nearby_networks=[]  # À implémenter si nécessaire
            )

            # Sauvegarder l'enregistrement
            with self.measurement_lock:
                self.records.append(record)
                self.current_cycle += 1

            collection_time = time.time() - start_time
            self.logger.info(f"Collecte terminée en {collection_time:.2f}s")
            self._log_record_summary(record)

            return record

        except Exception as e:
            self.logger.error(f"Erreur lors de la collecte: {str(e)}", exc_info=True)
            return None

    def _create_network_status(self, interface_info: Dict) -> NetworkStatus:
        """Crée un objet NetworkStatus à partir des infos d'interface"""
        try:
            return NetworkStatus(
                link_speed_mbps=int(interface_info.get('phy_rate_mbps', 0)),
                rx_rate_mbps=interface_info.get('rx_rate_mbps', 0),
                tx_rate_mbps=interface_info.get('tx_rate_mbps', 0)
            )
        except Exception as e:
            self.logger.error(f"Erreur création NetworkStatus: {str(e)}")
            return NetworkStatus(0, 0, 0)

    def _log_record_summary(self, record: WifiRecord):
        """Log un résumé de l'enregistrement collecté"""
        if record.wifi_measurement:
            self.logger.info(f"Connecté à {record.wifi_measurement.ssid} ({record.wifi_measurement.signal_percent}%)")
        else:
            self.logger.info("Non connecté au WiFi")

        if record.ping_measurement:
            self.logger.info(f"Ping : {record.ping_measurement.avg_ms:.1f}ms ({record.ping_measurement.lost_percent:.0f}% perdu)")

        if record.nearby_networks:
            self.logger.info(f"Réseaux à proximité : {len(record.nearby_networks)}")

    def _scan_networks(self) -> List[Dict]:
        """Scanner les réseaux WiFi disponibles"""
        try:
            cmd = ["netsh", "wlan", "show", "networks", "mode=bssid"]
            result = subprocess.run(cmd,
                                  capture_output=True,
                                  text=True,
                                  encoding='latin1',  # Encodage nécessaire pour netsh
                                  check=True)

            self.logger.debug("Scan réseau réussi")
            networks = parse_networks_output(result.stdout)
            if networks:
                self.logger.info(f"Nombre de réseaux trouvés : {len(networks)}")
                return networks
            else:
                self.logger.warning("Aucun réseau trouvé dans le scan")
                # Écrire le contenu dans un fichier pour debug
                try:
                    debug_file = os.path.join(self.base_path, 'netsh_debug.txt')
                    with open(debug_file, 'w', encoding='latin1') as f:
                        f.write(result.stdout)
                    self.logger.debug(f"Contenu netsh écrit dans {debug_file}")
                except Exception as e:
                    self.logger.error(f"Erreur écriture fichier debug: {str(e)}")
                return []
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Erreur lors du scan : {e.stderr}")
            return []
        except Exception as e:
            self.logger.error(f"Erreur lors du scan réseau : {str(e)}")
            return []

    def _get_interface_info(self) -> Optional[InterfaceInfo]:
        """Obtient les informations de l'interface active"""
        try:
            cmd = ["netsh", "wlan", "show", "interface"]
            result = subprocess.run(cmd,
                                  capture_output=True,
                                  text=True,
                                  encoding='latin1',  # Encodage nécessaire pour netsh
                                  check=True)

            self.logger.debug("Lecture interface réussie")
            interface_info = parse_interface_output(result.stdout)
            if interface_info:
                if interface_info.get('is_connected'):
                    self.logger.debug(f"Interface connectée trouvée : {interface_info['ssid']}")
                else:
                    self.logger.debug(f"Interface trouvée mais non connectée : {interface_info.get('interface_name', 'Inconnue')}")
                return interface_info
            else:
                self.logger.warning("Aucune interface WiFi trouvée")
                # Écrire le contenu dans un fichier pour debug
                try:
                    debug_file = os.path.join(self.base_path, 'interface_debug.txt')
                    with open(debug_file, 'w', encoding='latin1') as f:
                        f.write(result.stdout)
                    self.logger.debug(f"Contenu interface écrit dans {debug_file}")
                except Exception as e:
                    self.logger.error(f"Erreur écriture fichier debug: {str(e)}")
                return None

        except subprocess.CalledProcessError as e:
            self.logger.error(f"Erreur interface : {e.stderr}")
            return None
        except Exception as e:
            self.logger.error(f"Erreur lecture interface : {str(e)}")
            return None

    def _get_ping_target(self):
        """Détermine la cible du ping (gateway ou 8.8.8.8) via config.yaml ou fallback."""
        config_path = os.path.join(os.path.dirname(__file__), 'config.yaml')
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    config = yaml.safe_load(f)
                # Permettre un champ ping_target dans config.yaml
                if 'ping_target' in config:
                    return config['ping_target']
            except Exception as e:
                self.logger.warning(f"Erreur lecture config.yaml pour ping_target: {e}")
        # Fallback sur 8.8.8.8
        return "8.8.8.8"

    def _auto_detect_ping_target(self):
        """Détecte automatiquement la meilleure cible de ping (config, DNS, localhost)."""
        candidates = []
        config_target = self._get_ping_target()
        if config_target:
            candidates.append(config_target)
        candidates.append('8.8.8.8')
        candidates.append('127.0.0.1')
        for target in candidates:
            try:
                cmd = f"ping -n 1 {target}"
                result = subprocess.run(cmd, capture_output=True, text=True, shell=True, timeout=3)
                if result.returncode == 0:
                    self.logger.info(f"Cible ping sélectionnée automatiquement : {target}")
                    return target
            except Exception:
                continue
        self.logger.warning("Aucune cible ping joignable détectée, fallback sur 8.8.8.8")
        return '8.8.8.8'

    def _write_debug_log(self, content: str, filename: str) -> None:
        """Écrit un contenu dans un fichier de debug avec gestion d'erreurs."""
        try:
            # Vérifier/créer le dossier
            if not os.path.exists(self.base_path):
                os.makedirs(self.base_path, exist_ok=True)
                self.logger.info(f"Dossier créé: {self.base_path}")

            # Chemin complet du fichier
            filepath = os.path.join(self.base_path, filename)

            # Vérifier les permissions
            dir_writable = os.access(self.base_path, os.W_OK)
            self.logger.debug(f"Dossier {self.base_path} est {'accessible' if dir_writable else 'inaccessible'} en écriture")

            # Écrire le fichier
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            self.logger.debug(f"Fichier debug créé: {filepath}")

            # Vérifier que le fichier existe
            if os.path.exists(filepath):
                size = os.path.getsize(filepath)
                self.logger.debug(f"Fichier {filepath} créé avec succès ({size} octets)")
            else:
                self.logger.error(f"Fichier {filepath} non créé malgré aucune erreur")

        except PermissionError as e:
            self.logger.error(f"Erreur de permission lors de l'écriture de {filename}: {e}")
        except Exception as e:
            self.logger.error(f"Erreur lors de l'écriture de {filename}: {e}")

    def _measure_ping(self) -> Optional[PingMeasurement]:
        """Effectue un test de ping vers la passerelle ou un serveur DNS fiable"""
        try:
            # Liste de cibles à tester dans l'ordre
            targets = [
                "10.136.136.1",  # Passerelle locale
                "8.8.8.8",       # Google DNS
                "1.1.1.1"        # Cloudflare DNS
            ]

            # Essayer chaque cible jusqu'à ce qu'une réponde
            for target in targets:
                self.logger.debug(f"Test ping vers {target}...")
                try:
                    # Forcer l'anglais pour avoir une sortie consistante
                    cmd = f"ping -n 4 {target}"
                    env = os.environ.copy()
                    env["LANG"] = "en_US.UTF-8"
                    result = subprocess.run(cmd,
                                         capture_output=True,
                                         text=True,
                                         shell=True,
                                         timeout=10,
                                         env=env)

                    if result.returncode == 0:
                        # Calculer les temps de réponse en utilisant plusieurs patterns possibles
                        times = []
                        lost = 0
                        for line in result.stdout.splitlines():
                            # Pattern FR: "temps=1 ms", "temps<1 ms", "temps="
                            # Pattern EN: "time=1ms", "time<1ms", "time="
                            # Pattern commun: "Request timed out", "délai d'attente"
                            if any(x in line.lower() for x in ["timed out", "délai d'attente", "expired", "perte"]):
                                lost += 1
                                continue

                            for pattern in [
                                r'(?:temps|time)[=<](\d+)',  # FR/EN avec = ou <
                                r'[=<](\d+)\s*ms',           # Général avec ms
                                r'temps\s*(?:de)?\s*(\d+)',  # FR spécifique
                                r'time\s*(?:of)?\s*(\d+)'    # EN spécifique
                            ]:
                                match = re.search(pattern, line, re.IGNORECASE)
                                if match:
                                    try:
                                        times.append(int(match.group(1)))
                                        break  # Sort de la boucle des patterns si on en a trouvé un
                                    except ValueError:
                                        continue

                        if times:
                            self.logger.debug(f"Temps de réponse : {times}")
                            return PingMeasurement(
                                target=target,
                                min_ms=min(times),
                                max_ms=max(times),
                                avg_ms=sum(times) / len(times),
                                lost_percent=((4 - len(times)) / 4) * 100,
                                jitter_ms=max(times) - min(times)
                            )

                except subprocess.TimeoutExpired:
                    self.logger.debug(f"Timeout ping vers {target}")
                except Exception as e:
                    self.logger.debug(f"Erreur ping vers {target}: {str(e)}")
                continue

            self.logger.warning("Toutes les cibles de ping ont échoué")
            return None        except Exception as e:
            self.logger.error(f"Erreur lors du test de ping: {str(e)}", exc_info=True)
            return None

    def _create_wifi_measurement(self, network_data: Dict) -> Optional[WifiMeasurement]:
        """Crée un objet WifiMeasurement à partir des données réseau"""
        try:
            # Vérifier que toutes les données requises sont présentes
            required_keys = ['ssid', 'bssid', 'signal_percent', 'channel', 'band']
            if not all(key in network_data for key in required_keys):
                missing = [key for key in required_keys if key not in network_data]
                self.logger.error(f"Données réseau manquantes : {missing}")
                return None

            # Si le BSSID n'est pas valide, ignorer ce réseau
            if not validate_bssid(network_data['bssid']):
                self.logger.warning(f"BSSID invalide ignoré : {network_data['bssid']}")
                return None

            # Calculer le signal en dBm à partir du pourcentage
            signal_dbm = _percent_to_dbm(network_data['signal_percent'])
            signal_percent = network_data['signal_percent']

            self.logger.debug(f"Création mesure WiFi: SSID={network_data['ssid']}, "
                          f"BSSID={network_data['bssid']}, "
                          f"Signal={signal_percent}% ({signal_dbm}dBm), "
                          f"Canal={network_data['channel']}, "
                          f"Bande={network_data['band']}")

            measurement = WifiMeasurement(
                ssid=network_data['ssid'],
                bssid=network_data['bssid'],
                signal_percent=signal_percent,
                signal_dbm=signal_dbm,
                channel=network_data['channel'],
                band=network_data['band'],
                frequency=network_data['band'],
                frequency_mhz=_channel_to_frequency_mhz(network_data['channel']),
                is_connected=False,
                channel_utilization=network_data.get('channel_utilization', 0.0)
            )

            # Stocker les valeurs originales du scan pour référence
            setattr(measurement, 'signal_from_scan', True)
            setattr(measurement, 'dbm_from_scan', signal_dbm)
            setattr(measurement, 'percent_from_scan', signal_percent)

            return measurement

        except Exception as e:
            self.logger.error(f"Erreur création mesure WiFi : {str(e)}", exc_info=True)
            return None

    def _create_wifi_measurement_from_interface(self, interface_info: Dict) -> Optional[WifiMeasurement]:
        """Crée un objet WifiMeasurement à partir des informations d'interface"""
        try:
            if not interface_info:
                self.logger.debug("Aucune information d'interface disponible")
                return None

            # Une interface peut être détectée mais pas connectée
            is_connected = interface_info.get('is_connected', False)

            # Si l'interface n'est pas connectée, elle n'aura pas de SSID ni de BSSID
            if not is_connected:
                self.logger.debug(f"Interface trouvée mais non connectée: {interface_info.get('interface_name', 'Inconnue')}")
                return None

            # Vérifier que toutes les données requises sont présentes pour une interface connectée
            required_keys = ['ssid', 'bssid', 'signal_percent']
            if not all(key in interface_info for key in required_keys):
                missing = [key for key in required_keys if key not in interface_info]
                self.logger.error(f"Données interface manquantes : {missing}")
                return None

            # Si le BSSID n'est pas valide, ignorer cette interface
            if not validate_bssid(interface_info['bssid']):
                self.logger.warning(f"BSSID invalide ignoré : {interface_info.get('bssid', 'Inconnu')}")
                return None

            self.logger.debug(f"Création mesure WiFi depuis interface: "
                          f"SSID={interface_info['ssid']}, "
                          f"BSSID={interface_info['bssid']}, "
                          f"Signal={interface_info['signal_percent']}%")

            # Utiliser des valeurs par défaut pour les champs manquants
            channel = interface_info.get('channel', 0)
            band = interface_info.get('frequency', '2.4 GHz')
            freq_mhz = interface_info.get('frequency_mhz', 0)

            # Si freq_mhz n'est pas défini mais que le canal est connu, calculer la fréquence
            if freq_mhz == 0 and channel > 0:
                freq_mhz = _channel_to_frequency_mhz(channel)

            return WifiMeasurement(
                ssid=interface_info['ssid'],
                bssid=interface_info['bssid'],
                signal_percent=interface_info['signal_percent'],
                signal_dbm=interface_info.get('signal_dbm', _percent_to_dbm(interface_info['signal_percent'])),
                channel=channel,
                band=band,
                frequency=band,
                frequency_mhz=freq_mhz,
                is_connected=is_connected,
                channel_utilization=0.0
            )

        except Exception as e:
            self.logger.error(f"Erreur création mesure WiFi depuis interface : {str(e)}", exc_info=True)
            return None

    def _scan_networks_with_retry(self, max_retries: int = RETRY_CONFIG['MAX_RETRIES']) -> List[Dict]:
        """Scanner les réseaux WiFi avec mécanisme de réessai"""
        for attempt in range(max_retries):
            try:
                networks = self._scan_networks()
                if networks:
                    return networks
                self.logger.warning(f"Tentative de scan {attempt + 1}/{max_retries} échouée, réessai...")
                time.sleep(RETRY_CONFIG['RETRY_DELAY'])
            except Exception as e:
                self.logger.error(f"Erreur lors de la tentative {attempt + 1}: {str(e)}")
                if attempt == max_retries - 1:
                    self.logger.error("Toutes les tentatives de scan ont échoué")
                    return []
                time.sleep(RETRY_CONFIG['RETRY_DELAY'])
        return []

    def _get_interface_info_with_retry(self, max_retries: int = RETRY_CONFIG['MAX_RETRIES']) -> Optional[InterfaceInfo]:
        """Obtenir les informations de l'interface avec mécanisme de réessai"""
        for attempt in range(max_retries):
            try:
                interface_info = self._get_interface_info()
                if interface_info:
                    return interface_info
                self.logger.warning(f"Tentative d'obtention interface {attempt + 1}/{max_retries} échouée, réessai...")
                time.sleep(RETRY_CONFIG['RETRY_DELAY'])
            except Exception as e:
                self.logger.error(f"Erreur lors de la tentative {attempt + 1}: {str(e)}")
                if attempt == max_retries - 1:
                    self.logger.error("Toutes les tentatives d'obtention interface ont échoué")
                    return None
                time.sleep(RETRY_CONFIG['RETRY_DELAY'])
        return None

    def _validate_measurement(self, measurement: Optional[WifiMeasurement]) -> bool:
        """Valide une mesure WiFi selon les critères définis"""
        if not measurement:
            return False

        # Vérifier les valeurs critiques
        if measurement.signal_dbm < WIFI_THRESHOLDS['SIGNAL_CRITICAL']:
            self.logger.warning(f"Signal critique détecté: {measurement.signal_dbm} dBm")
            return False

        # Vérifier la cohérence des données
        if measurement.signal_percent < 0 or measurement.signal_percent > 100:
            self.logger.error(f"Pourcentage de signal invalide: {measurement.signal_percent}%")
            return False

        return True    def _merge_measurements(self, wifi_measurement: WifiMeasurement, interface_info: InterfaceInfo) -> WifiMeasurement:
        """Fusionne les données de scan avec les infos d'interface en validant"""
        try:
            if not wifi_measurement:
                self.logger.debug("Mesure WiFi manquante, utilisation des infos d'interface uniquement")
                return self._create_wifi_measurement_from_interface(interface_info)

            if not interface_info:
                self.logger.debug("Info interface manquante, utilisation des données de scan uniquement")
                return wifi_measurement

            # Vérifier la cohérence des BSSID
            scan_bssid = re.sub(r'[^a-fA-F0-9]', '', wifi_measurement.bssid).lower()
            interface_bssid = re.sub(r'[^a-fA-F0-9]', '', interface_info.get('bssid', '')).lower()

            if interface_bssid and scan_bssid and scan_bssid != interface_bssid:
                self.logger.warning(f"Incohérence des BSSID entre scan ({wifi_measurement.bssid}) et interface ({interface_info.get('bssid')})")
                # Si les BSSID sont différents, nous gardons quand même les données pour le réseau connecté
                self.logger.debug("Utilisation des données de l'interface pour le réseau connecté")

            # Marquer toujours comme connecté si l'interface l'indique
            wifi_measurement.is_connected = interface_info.get('is_connected', False)

            # Préférer les données de signal de l'interface pour le réseau connecté
            if 'signal_dbm' in interface_info and interface_info['signal_dbm'] is not None:
                wifi_measurement.signal_dbm = interface_info['signal_dbm']
                self.logger.debug(f"Signal dBm mis à jour depuis l'interface: {wifi_measurement.signal_dbm}")

            if 'signal_percent' in interface_info and interface_info['signal_percent'] is not None:
                wifi_measurement.signal_percent = interface_info['signal_percent']
                self.logger.debug(f"Signal % mis à jour depuis l'interface: {wifi_measurement.signal_percent}")

            # Si le signal est manquant ou 0 dans les données de l'interface mais présent dans le scan,
            # utiliser le signal du scan
            if (wifi_measurement.signal_percent == 0 or wifi_measurement.signal_dbm == -100) and hasattr(wifi_measurement, 'signal_from_scan'):
                self.logger.debug("Utilisation des données de signal du scan car signal interface = 0")
                if hasattr(wifi_measurement, 'dbm_from_scan'):
                    wifi_measurement.signal_dbm = wifi_measurement.dbm_from_scan
                if hasattr(wifi_measurement, 'percent_from_scan'):
                    wifi_measurement.signal_percent = wifi_measurement.percent_from_scan

            # Mettre à jour la vitesse de connexion
            if 'phy_rate_mbps' in interface_info and interface_info['phy_rate_mbps']:
                try:
                    wifi_measurement.link_speed = int(interface_info['phy_rate_mbps'])
                except (ValueError, TypeError):
                    self.logger.warning(f"Valeur phy_rate_mbps invalide: {interface_info['phy_rate_mbps']}")

            # Fréquence et canal peuvent être plus précis depuis l'interface
            if 'frequency_mhz' in interface_info and interface_info['frequency_mhz']:
                wifi_measurement.frequency_mhz = interface_info['frequency_mhz']

            if 'frequency' in interface_info and interface_info['frequency']:
                wifi_measurement.frequency = interface_info['frequency']

            if 'channel' in interface_info and interface_info['channel']:
                wifi_measurement.channel = interface_info['channel']

            return wifi_measurement

        except Exception as e:
            self.logger.error(f"Erreur lors de la fusion des mesures: {str(e)}")
            return wifi_measurement

    def set_location_tag(self, tag: str):
        """Définit le tag de localisation pour les mesures"""
        self.current_location_tag = tag
        self.logger.info(f"Tag de localisation défini : {tag}")

    def set_zone(self, zone: str):
        """Définit la zone pour les mesures"""
        self.current_zone = zone
        self.logger.info(f"Zone définie : {zone}")

    def export_records(self, filename: Optional[str] = None) -> str:
        """Exporte les enregistrements dans un fichier JSON"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"wifi_records_{timestamp}.json"

        filepath = os.path.join(self.base_path, filename)

        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump([record.to_dict() for record in self.records], f, indent=2)
            self.logger.info(f"Records exportés dans {filepath}")
            return filepath
        except Exception as e:
            self.logger.error(f"Erreur lors de l'export : {str(e)}")
            raise

def _percent_to_dbm(percent: int) -> int:
    """Convertit un pourcentage de signal en dBm (approximation)"""
    if percent >= 100:
        return -50
    elif percent <= 0:
        return -100
    return int(-100 + (percent / 2))

def _channel_to_frequency_mhz(channel: int) -> int:
    """Convertit un numéro de canal en fréquence MHz"""
    if 1 <= channel <= 14:  # 2.4 GHz
        return 2407 + (channel * 5)
    elif 36 <= channel <= 165:  # 5 GHz
        return 5000 + (channel * 5)
    return 0
