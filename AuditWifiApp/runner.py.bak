# -*- coding: utf-8 -*-
import os
import json
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from dotenv import load_dotenv
from datetime import datetime
import logging
import sys

from wifi_data_collector import WifiDataCollector
from config_manager import ConfigurationManager
from log_manager import LogManager
from wifi_test_manager import WifiTestManager
from src.ai.simple_moxa_analyzer_new import analyze_moxa_logs
from src.ai.simple_wifi_analyzer import analyze_wifi_data

# Configuration de la journalisation
logging.basicConfig(
    filename="api_errors.log",
    level=logging.ERROR,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Charger les variables d'environnement
load_dotenv()

class MoxaAnalyzerUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Analyseur de Configuration Moxa")

        # Configuration par défaut
        self.max_log_length = 20000  # Augmentation de la limite de logs à 20 000 caractères
        default_config = {
            "min_transmission_rate": 6,
            "max_transmission_power": 20,
            "rts_threshold": 512,
            "fragmentation_threshold": 2346,
            "roaming_mechanism": "signal_strength",
            "roaming_difference": 9,
            "remote_connection_check": True,
            "wmm_enabled": True,
            "turbo_roaming": True,
            "ap_alive_check": True,
            "roaming_threshold_type": "signal_strength",
            "roaming_threshold_value": -70,
            "ap_candidate_threshold_type": "signal_strength",
            "ap_candidate_threshold_value": -70
        }

        # Utilisation de ConfigurationManager, LogManager et WifiTestManager
        self.config_manager = ConfigurationManager(default_config)
        self.log_manager = LogManager()
        self.wifi_test_manager = WifiTestManager(WifiDataCollector())
        self.setup_ui()

    def setup_ui(self):
        # Frame principal avec padding réduit
        main_frame = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Frame gauche (configuration)
        left_frame = ttk.Frame(main_frame)
        main_frame.add(left_frame, weight=1)
        
        # Frame droite (résultats)
        right_frame = ttk.Frame(main_frame)
        main_frame.add(right_frame, weight=1)
        
        # Notebook pour organiser les sections de gauche
        left_notebook = ttk.Notebook(left_frame)
        left_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Onglet Configuration
        config_tab = ttk.Frame(left_notebook)
        left_notebook.add(config_tab, text="Configuration")
        self.setup_config_section(config_tab)
        
        # Onglet Logs
        logs_tab = ttk.Frame(left_notebook)
        left_notebook.add(logs_tab, text="Logs")
        self.setup_logs_input_section(logs_tab)
        
        # Onglet Tests WiFi
        wifi_tab = ttk.Frame(left_notebook)
        left_notebook.add(wifi_tab, text="Tests WiFi")
        self.setup_wifi_test_section(wifi_tab)
        
        # Configuration de la section résultats
        self.setup_results_section(right_frame)

    def setup_config_section(self, parent):
        # Configuration Frame
        config_frame = ttk.LabelFrame(parent, text="Configuration Moxa", padding=10)
        config_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Ajouter les champs de configuration...
        self.add_config_fields(config_frame)

        # Ajouter les boutons Sauvegarder et Charger
        button_frame = ttk.Frame(config_frame)
        button_frame.pack(fill=tk.X, pady=5)

        ttk.Button(button_frame, text="Sauvegarder", command=self.save_config).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Charger", command=self.load_config).pack(side=tk.LEFT, padx=5)

    def add_config_fields(self, frame):
        # Créer un canvas avec scrollbar pour les paramètres de configuration
        canvas = tk.Canvas(frame)
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=canvas.yview)
        config_frame = ttk.Frame(canvas)
        
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Pack les widgets
        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        
        # Créer une fenêtre dans le canvas pour le frame
        canvas_window = canvas.create_window((0, 0), window=config_frame, anchor="nw")
        
        # Créer les champs pour chaque paramètre de configuration
        row = 0
        for key, value in self.config_manager.get_config().items():
            label = ttk.Label(config_frame, text=key.replace("_", " ").title())
            label.grid(row=row, column=0, sticky=tk.W, padx=2, pady=1)
            
            if isinstance(value, bool):
                var = tk.BooleanVar(value=value)
                widget = ttk.Checkbutton(config_frame, variable=var)
            else:
                var = tk.StringVar(value=str(value))
                entry = ttk.Entry(config_frame, textvariable=var, width=15)
                widget = entry
            
            widget.grid(row=row, column=1, sticky=tk.W, padx=2, pady=1)
            setattr(self, f"var_{key}", var)
            row += 1
        
        # Configurer le scrolling
        def configure_scroll(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        
        def configure_canvas(event):
            canvas.itemconfig(canvas_window, width=event.width)
        
        config_frame.bind("<Configure>", configure_scroll)
        canvas.bind("<Configure>", configure_canvas)

    def setup_logs_input_section(self, parent):
        logs_input_frame = ttk.LabelFrame(parent, text="Logs Moxa", padding=10)
        logs_input_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Zone de texte pour saisir les logs
        text_frame = ttk.Frame(logs_input_frame)
        text_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.logs_input_text = tk.Text(text_frame, wrap=tk.WORD, height=10)
        self.logs_input_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=self.logs_input_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.logs_input_text.configure(yscrollcommand=scrollbar.set)

        # Boutons d'analyse
        analyze_button_frame = ttk.Frame(logs_input_frame)
        analyze_button_frame.pack(fill=tk.X, pady=5)

        # Bouton d'analyse par l'IA
        analyze_btn = ttk.Button(analyze_button_frame, 
                          text="Analyser",
                          command=self.analyze_logs_from_input)
        analyze_btn.pack(side=tk.LEFT, padx=5)

        # Bouton pour charger depuis un fichier
        file_btn = ttk.Button(analyze_button_frame, 
                           text="Charger depuis fichier",
                           command=self.analyze_logs_from_file)
        file_btn.pack(side=tk.RIGHT, padx=5)

    def setup_wifi_test_section(self, parent):
        """Configure la section pour les tests Wi-Fi"""
        wifi_test_frame = ttk.LabelFrame(parent, text="Tests Wi-Fi", padding=10)
        wifi_test_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Boutons pour démarrer et arrêter les tests
        self.start_wifi_test_button = ttk.Button(wifi_test_frame, text="Démarrer le test Wi-Fi", command=self.start_wifi_test)
        self.start_wifi_test_button.pack(fill=tk.X, pady=2)

        self.stop_wifi_test_button = ttk.Button(wifi_test_frame, text="Arrêter le test Wi-Fi", command=self.stop_wifi_test, state=tk.DISABLED)
        self.stop_wifi_test_button.pack(fill=tk.X, pady=2)

        # Zone de texte pour afficher les résultats des tests Wi-Fi
        wifi_results_frame = ttk.Frame(wifi_test_frame)
        wifi_results_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.wifi_test_results_text = tk.Text(wifi_results_frame, wrap=tk.WORD, height=10)
        self.wifi_test_results_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Scrollbar pour la zone de texte
        scrollbar = ttk.Scrollbar(wifi_results_frame, orient=tk.VERTICAL, command=self.wifi_test_results_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.wifi_test_results_text.configure(yscrollcommand=scrollbar.set)

    def setup_results_section(self, parent):
        results_frame = ttk.Frame(parent)
        results_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

        # Frame pour le titre des résultats
        title_frame = ttk.Frame(results_frame)
        title_frame.pack(fill=tk.X, padx=2, pady=1)
        ttk.Label(title_frame, text="Résultats d'analyse", font=("TkDefaultFont", 10, "bold")).pack(side=tk.LEFT)

        # Ajouter un bouton pour sauvegarder les résultats
        self.save_button = ttk.Button(title_frame, text="Sauvegarder", command=lambda: self.save_results(self.last_analysis_results))
        self.save_button.pack(side=tk.RIGHT, padx=5)
        self.save_button.config(state=tk.DISABLED)  # Désactivé par défaut

        # Zone de texte pour les résultats avec scrollbar
        text_frame = ttk.Frame(results_frame)
        text_frame.pack(fill=tk.BOTH, expand=True)
        
        self.results_text = tk.Text(text_frame, wrap=tk.WORD)
        self.results_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=self.results_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.results_text.configure(yscrollcommand=scrollbar.set)

    # Méthodes de fonctionnalités générales

    def analyze_logs_from_input(self, log_content=None):
        """Analyse les logs Moxa à partir de l'entrée utilisateur ou d'un contenu fourni."""
        try:
            if log_content is None:
                log_content = self.logs_input_text.get(1.0, tk.END)
            
            if len(log_content.strip()) < 10:
                messagebox.showwarning("Avertissement", "Veuillez entrer un contenu de log suffisant pour l'analyse.")
                return
            
            # Limiter la taille des logs si nécessaire
            if len(log_content) > self.max_log_length:
                log_content = log_content[:self.max_log_length]
                messagebox.showinfo("Info", f"Le contenu des logs a été tronqué à {self.max_log_length} caractères pour l'analyse.")
            
            # Effacer les résultats précédents
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, "Analyse en cours...\n")
            self.root.update()  # Mise à jour de l'interface

            # Obtenir la configuration actuelle
            current_config = self.get_current_config()
            
            # Utiliser l'analyseur simplifié pour Moxa
            results = analyze_moxa_logs(log_content, current_config)
            
            # Afficher directement la réponse brute d'OpenAI
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, results)
            
            # Activer le bouton de sauvegarde
            self.save_button.config(state=tk.NORMAL)
            
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'analyse: {str(e)}")

    # Méthodes Wi-Fi Test
    def start_wifi_test(self):
        """Démarre le test Wi-Fi."""
        # Initialiser la liste pour stocker toutes les données Wi-Fi collectées
        self.collected_wifi_data = []
        self.wifi_test_manager.start_wifi_test(self.update_wifi_test_results)
        self.start_wifi_test_button.config(state=tk.DISABLED)        self.stop_wifi_test_button.config(state=tk.NORMAL)
        self.wifi_test_results_text.delete(1.0, tk.END)  # Effacer les résultats précédents
        self.wifi_test_results_text.insert(tk.END, "Test Wi-Fi démarré...\n")
        
    def stop_wifi_test(self):
        """Arrête le test Wi-Fi."""
        self.wifi_test_manager.stop_wifi_test()
        self.start_wifi_test_button.config(state=tk.NORMAL)
        self.stop_wifi_test_button.config(state=tk.DISABLED)
        self.wifi_test_results_text.insert(tk.END, "Test Wi-Fi arrêté. Analyse en cours...\n")
        # Analyse des données collectées
        self.analyze_wifi_test_logs()
        
    def update_wifi_test_results(self, result):
        """Met à jour l'interface utilisateur avec les résultats des tests Wi-Fi."""
        # Afficher le résultat dans l'interface
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # Vérifier si le résultat est un WifiRecord comme attendu
        if hasattr(result, 'wifi_measurement'):
            wifi_measurement = result.wifi_measurement
            info_line = f"[{timestamp}] SSID: {wifi_measurement.ssid}, Signal: {wifi_measurement.signal_strength}, Canal: {wifi_measurement.channel}\n"
        else:
            info_line = f"[{timestamp}] {result}\n"
            
        self.wifi_test_results_text.insert(tk.END, info_line)
        self.wifi_test_results_text.see(tk.END)

        # Stocker les données pour analyse future
        network_data = {
            "timestamp": timestamp,
            "scan_number": len(self.collected_wifi_data) + 1
        }
        
        # Ajouter les données du wifi_measurement si disponible
        if hasattr(result, 'wifi_measurement'):
            wifi_measurement = result.wifi_measurement
            network_data.update({
                "ssid": wifi_measurement.ssid,
                "bssid": wifi_measurement.bssid,
                "signal_dbm": wifi_measurement.signal_strength,  # Attention: signal_strength pour dBm
                "signal_percent": int((100 + wifi_measurement.signal_strength) * 2) if wifi_measurement.signal_strength > -100 else 0,  # Conversion approximative
                "channel": wifi_measurement.channel,
                "frequency": wifi_measurement.frequency,
                "frequency_mhz": int(wifi_measurement.frequency.replace("GHz", "").strip()) * 1000 if "GHz" in str(wifi_measurement.frequency) else 0,
                "channel_stability": "stable"  # Par défaut
            })
        else:
            # Fallback pour les formats de données non reconnus
            network_data.update({
                "ssid": getattr(result, 'ssid', "Inconnu"),
                "bssid": getattr(result, 'bssid', "Inconnu"),
                "signal_dbm": getattr(result, 'signal_dbm', -100),
                "signal_percent": getattr(result, 'signal_percent', 0),
                "channel": getattr(result, 'channel', 0),
                "frequency": getattr(result, 'frequency', "Inconnu"),
                "frequency_mhz": getattr(result, 'frequency_mhz', 0),
                "channel_stability": "stable"  # Par défaut
            })
            
        self.collected_wifi_data.append(network_data)
        
    def analyze_wifi_test_logs(self):
        """Analyse les logs du test Wi-Fi à partir des données collectées"""
        if not hasattr(self, 'collected_wifi_data') or not self.collected_wifi_data:
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, "Aucune donnée Wi-Fi collectée à analyser.\n")
            return

        try:
            # Effacer les résultats précédents
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, "Analyse des données WiFi en cours...\n")
            self.root.update()

            # Utiliser l'analyseur simplifié pour WiFi
            results = analyze_wifi_data(self.collected_wifi_data)
            
            # Afficher directement la réponse brute d'OpenAI
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, results)
            
            # Activer le bouton de sauvegarde
            self.save_button.config(state=tk.NORMAL)
            
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'analyse WiFi : {str(e)}")

    # Méthodes utilitaires
    def get_current_config(self):
        """Retourne la configuration actuelle."""
        config = {}
        for key in self.config_manager.get_config().keys():
            var = getattr(self, f"var_{key}")
            value = var.get()
            # Conversion des types si nécessaire
            if key in ["min_transmission_rate", "max_transmission_power", "rts_threshold", 
                      "fragmentation_threshold", "roaming_difference", "roaming_threshold_value",
                      "ap_candidate_threshold_value"]:
                try:
                    value = float(value)
                except ValueError:
                    # En cas d'erreur de conversion, garder la valeur telle quelle
                    pass
            config[key] = value
        return config

    def analyze_logs_from_file(self):
        """Permet de charger un fichier de logs et de lancer l'analyse."""
        filename = filedialog.askopenfilename(
            title="Sélectionner un fichier de logs",
            filetypes=[("Fichiers texte", "*.txt *.log"), ("Tous les fichiers", "*.*")],
            initialdir="logs_moxa"
        )
        if filename:
            try:
                with open(filename, "r", encoding="utf-8") as f:
                    log_content = f.read()
                self.analyze_logs_from_input(log_content=log_content)
            except Exception as e:
                messagebox.showerror("Erreur", f"Erreur lors de la lecture du fichier : {str(e)}")

    def save_config(self):
        """Sauvegarde la configuration actuelle."""
        filepath = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filepath:
            config = self.get_current_config()
            self.config_manager.set_config(config)
            self.config_manager.save_config(filepath)
            messagebox.showinfo("Succès", "Configuration sauvegardée avec succès.")

    def load_config(self):
        """Charge une configuration à partir d'un fichier."""
        filepath = filedialog.askopenfilename(
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filepath:
            try:
                config = self.config_manager.load_config(filepath)
                # Mettre à jour les variables de l'interface
                for key, value in config.items():
                    var = getattr(self, f"var_{key}", None)
                    if var is not None:
                        var.set(value)
                messagebox.showinfo("Succès", "Configuration chargée avec succès.")
            except Exception as e:
                messagebox.showerror("Erreur", f"Erreur lors du chargement de la configuration : {str(e)}")

    def save_results(self, results):
        """Sauvegarde les résultats d'analyse dans un fichier JSON"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"logs_moxa/results_{timestamp}.json"
        
        # Créer le dossier logs_moxa si nécessaire
        os.makedirs("logs_moxa", exist_ok=True)
        
        try:
            # Convertir les résultats en JSON
            with open(filename, "w", encoding="utf-8") as f:
                json.dump(results, f, indent=2, ensure_ascii=False)
            
            messagebox.showinfo("Succès", f"Résultats sauvegardés dans {filename}")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de la sauvegarde des résultats : {str(e)}")


# Fonction principale pour lancer l'application
def main():
    """Fonction principale pour lancer l'application"""
    try:
        root = tk.Tk()
        root.title("Analyseur de Configuration Moxa")
        root.geometry("1200x800")  # Taille de fenêtre par défaut
        app = MoxaAnalyzerUI(root)
        root.mainloop()
    except Exception as e:
        print(f"Erreur lors du démarrage de l'application : {str(e)}")
        sys.exit(1)

# Point d'entrée principal
if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Erreur fatale : {str(e)}")
        sys.exit(1)
